import tkinter as tk
from tkinter import ttk
import threading
import random
import time
from model import get_model_response  
import logging
import json  
import requests


logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

def load_commands(filename):
    try:
        with open(filename, 'r') as file:
            commands = [line.strip() for line in file.readlines()]
        logging.info(f'Loaded {len(commands)} commands successfully.')
        return commands
    except Exception as e:
        logging.error("Failed to load commands: " + str(e))
        return []


def apply_button_style():
    style = ttk.Style()
    style.theme_use('default')
    style.configure('Modern.TButton', 
                    background='#eeeee4', 
                    foreground='black', 
                    width=20, 
                    borderwidth=1, 
                    focusthickness=3, 
                    focuscolor='none',
                    font=('Helvetica', 12, 'bold'))
    style.map('Modern.TButton', 
              background=[('active', '#6564DB'), ('pressed', '#00397a')],
              foreground=[('pressed', 'white'), ('active', 'white')],
              relief=[('pressed', 'sunken'), ('!pressed', 'raised')])

class TypingTestApp:
    def __init__(self, master, commands):
        self.master = master
        self.master.title("AI PenTest Practice Studio")
        self.commands = commands
        self.current_command = random.choice(self.commands)
        self.active_thread = None
        self.thread_stop_event = threading.Event()

        
        background_color = "#f5f5f5"
        text_color = "#333333"
        title_color = "#6564DB"
        scrollbar_color = "#a0a0a0"

        self.label = tk.Label(master, text="Type the command below as fast and as accurately as you can.",
                              font=("Segoe UI", 14), bg=background_color, fg=title_color)
        self.label.pack()

        self.command_label = tk.Label(master, text=self.current_command, font=("Segoe UI", 16),
                                      bg=background_color, fg=text_color)
        self.command_label.pack()

        self.entry = tk.Entry(master, font=("Segoe UI", 16), width=100, bg="white", fg=text_color)
        self.entry.pack()
        self.entry.bind("<KeyRelease>", self.check_typing)

        self.result_label = tk.Label(master, text="", font=("Segoe UI", 14), bg=background_color, fg=text_color)
        self.result_label.pack()

        self.text_frame = tk.Frame(master, bg=background_color)
        self.text_frame.pack(fill=tk.BOTH, expand=True)

        self.explanation_text = tk.Text(self.text_frame, height=10, wrap=tk.WORD, font=("Segoe UI", 14),
                                        bg=background_color, fg=text_color)
        self.explanation_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        self.scrollbar = tk.Scrollbar(self.text_frame, orient="vertical", command=self.explanation_text.yview, bg=scrollbar_color)
        self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.explanation_text.config(yscrollcommand=self.scrollbar.set)

        self.restart_button = ttk.Button(master, text="Next Command", style='Modern.TButton', command=self.load_new_command)
        self.restart_button.pack(fill=tk.X, expand=True) 
        self.restart_button.pack()

        
        self.update_explanation(self.current_command)
        self.start_time = time.time()

    def on_text_scroll(self, *args):
        self.scrollbar.set(*args)

    def update_explanation(self, line):
        """Updates the explanation text for the given command."""
        self.explanation_text.delete('1.0', tk.END)  
        self.explanation_text.insert(tk.END, f"Command: {line}\n")  

        if self.active_thread and self.active_thread.is_alive():
            self.thread_stop_event.set() 
            self.active_thread.join()  

        self.thread_stop_event.clear()  
        self.active_thread = threading.Thread(target=self.fetch_response, args=(line,))
        self.active_thread.start()

    def fetch_response(self, line):
        """Fetch the response for the command using an API call."""
        prompt = f"Please provide a comprehensive analysis of the command '{line}', detailing its function, syntax, security considerations, typical use cases in penetration testing or bug bounty, and any potential vulnerabilities associated with its use."
        url = 'http://localhost:11434/api/generate'
        headers = {'Content-Type': 'application/json'}
        data = {
            "model": "dolphin-llama3:8b-256k",
            "prompt": prompt,
            "options": {"num_ctx": 256000}
        }

        try:
            response = requests.post(url, json=data, headers=headers, stream=True)
            response.raise_for_status()
            for decoded_line in response.iter_lines():
                if self.thread_stop_event.is_set():
                    break  
                if decoded_line:
                    json_response = json.loads(decoded_line)
                    response_text = json_response.get('response', '')
                    if response_text: 
                        self.explanation_text.after(0, lambda text=response_text: self.append_text(text))
                if json_response.get('done', False):
                    break
        except requests.exceptions.RequestException as e:
            self.explanation_text.after(0, lambda: self.explanation_text.insert(tk.END, f"An error occurred: {str(e)}\n"))

    def append_text(self, text):
        """Appends text to the end of the Text widget."""
        at_bottom = self.explanation_text.yview()[1] == 1.0  
        self.explanation_text.insert(tk.END, text)  
        if at_bottom:  
         self.explanation_text.see(tk.END)



    def check_typing(self, event):
        typed_text = self.entry.get().strip()  
        if typed_text == self.current_command:
            end_time = time.time()
            elapsed_time = end_time - self.start_time
            minutes = int(elapsed_time // 60)
            seconds = int(elapsed_time % 60)
            time_text = f"{minutes} minutes, {seconds} seconds." if minutes > 0 else f"{seconds} seconds."
            self.result_label.config(text=f"Correct! Time taken: {time_text}", fg="green")
            self.entry.config(state='disabled')
        elif self.current_command.startswith(typed_text):
            self.result_label.config(text="", fg="black")  
        else:
            self.result_label.config(text="Incorrect!", fg="red")
    
    def load_new_command(self):
        """Load a new command, stopping any active threads."""
        if self.active_thread is not None:
            self.thread_stop_event.set()  
            self.active_thread.join()  

        self.current_command = random.choice(self.commands)
        self.command_label.config(text=self.current_command)
        self.entry.config(state='normal')
        self.entry.delete(0, tk.END)
        self.result_label.config(text="")
        self.start_time = time.time()  
        self.update_explanation(self.current_command)

def main():
    root = tk.Tk()
    root.title("AI PenTest Practice Studio")
    apply_button_style()
    commands = load_commands('commands.txt')
    app = TypingTestApp(root, commands)
    root.mainloop()

if __name__ == "__main__":
    main()